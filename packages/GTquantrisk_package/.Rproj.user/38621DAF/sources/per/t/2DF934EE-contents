#==============================================================================#
#                          Swaps Shiny App Run file                            #
#==============================================================================#


setwd("/Users/aherraez/Downloads/Swaps 2022/Shiny App")


#-------------------------------------------------------------------------------
# Install Packages
#-------------------------------------------------------------------------------

install.packages("/Users/aherraez/Downloads/Swaps 2022/Package/gtSWAP_0.1.0.tar.gz",repos = NULL, type = "source")

requiredPackages <- c("ggplot2","dplyr","maps","reshape2","tidyverse","ggthemes","plotly","DT","lubridate","readxl","shiny","shinydashboard", "RQuantLib","shinyjs", "rintrojs", "shinyWidgets", "shinycssloaders","RcppQuantuccia")
#
# #requiredPackages <- c("ISOcodes","ggplot2","grid","rworldmap","leaflet","RColorBrewer",
#                       "scales","lattice","dplyr","maps","reshape2","ggiraph","sf","sp",
#                       "colormap","rnaturalearth","tidyverse","gapminder","echarts4r",
#                       "gganimate","ggiraph","widgetframe","ggthemes","plotly","viridis",
#                       "DT","lubridate","readxl","shiny","shinydashboard", "RQuantLib",
#                       "shinyjs","fmdates", "rintrojs", "shinyWidgets", "shinycssloaders",
#                       "RcppQuantuccia")

ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg))
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

ipak(requiredPackages)

require(gtSWAP)







#-------------------------------------------------------------------------------
# Load Input Sheet
#-------------------------------------------------------------------------------


i_excel_input_path <- "/Users/aherraez/Downloads/Swaps 2022/Briongloid/InputSheetSugi3.xlsx"




inputs <- read_excel(i_excel_input_path)


for(i in 1:nrow(inputs)){
  if(inputs$Format[i] == 1){
    assign(paste(inputs$Variable[i]),as.Date(as.numeric(inputs$Value[i]),format = '%d/%m/%Y',origin = '30/12/1899'),envir = .GlobalEnv)
  } else if(inputs$Format[i] == 2){
    assign(paste(inputs$Variable[i]),NULL,envir = .GlobalEnv)
  } else if(inputs$Format[i] == 3){
    assign(paste(inputs$Variable[i]),as.numeric(inputs$Value[i]),envir = .GlobalEnv)
  } else if(inputs$Format[i] == 4){
    assign(paste(inputs$Variable[i]),as.Date(unlist(str_split(inputs$Value[i],",")), format = "%d/%m/%Y"), envir = .GlobalEnv)
  } else{
    assign(paste(inputs$Variable[i]),inputs$Value[i],envir = .GlobalEnv)
  }
}







#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

get_dates <- function(i_first_reset_date, i_maturity_date, i_calendar, i_effective_date, i_valuation_date, i_pay_freq) {

  #-------------------------------------------------------------------------------
  # Date formatting and business day checks
  #-------------------------------------------------------------------------------

  # Dataframe of all dates in the time period and whether they are business days or not
  date_vec <- as.Date(seq(from = i_first_reset_date, to = i_maturity_date+365,by = 'days'),format = "%Y-%m-%d") # +365 to avoid error when the maturity date is adjusted outside of vector for falling on a non-business day

  setCalendar(i_calendar)

  if (i_calendar == "NoAdjustments") {
    bus_day <- rep(TRUE, length(date_vec))  # for no adjustments all days are considered business days
  } else {
    bus_day <- isBusinessDay(
      #i_calendar,
      date_vec)
  }

  date_tab <- data.frame(date_vec, bus_day)


  pay_dates <- sort(seq.Date(from = i_maturity_date, to = i_effective_date , by = paste0("-", i_pay_freq)))
  pay_dates <- pay_dates[pay_dates >= i_valuation_date]

  # Adjust to set dates only on business days
  pay_dates <- f_BusinessDayAdjustment(as.Date(pay_dates),date_tab)

  return (pay_dates)
}




f_Inflation <- function(Inflation_excel_path, t_valuation_df, i_maturity_date, i_first_reset_date ,i_notional, i_pay_freq, i_fx) {

  # Get table from excel and drop NAs
  inflation_data <- readxl::read_excel(Inflation_excel_path)
  inflation_data <- inflation_data %>% drop_na(Reset_Rate)

  # Set up lag based on payment frequency
  input_values <- c("week", "month", "quarter", "6 month", "year")  # possible inputs for payment frequency
  numeric_values <- c(7,1,3,6,12)  # corresponding values to be used for lag
  df <- data.frame(input_values, numeric_values)
  lag <- df[match(i_pay_freq, df$input_values),2]


  # Use days function for weekly payments otherwise use months function
  if (i_pay_freq == "week") {
    inflation_data$pay_d <- inflation_data$Reset_Date + days(lag)
  } else {
    inflation_data$pay_d <- inflation_data$Reset_Date %m+% months(lag)
  }

  # Vector of all dates from first reset to maturity
  date_vec <- data.frame("date" = as.Date(seq(from = i_first_reset_date, to = i_maturity_date+365,by = 'days'),format = "%Y-%m-%d"))

  # Data frame of all possible pay_dates and their corresponding index ratio
  # If index data not available, the nearest non-NA index before is chosen
  inflation_df <- left_join(date_vec, inflation_data, by = c("date" = "pay_d"))
  inflation_df$Reset_Rate <- zoo::na.locf(inflation_df$Reset_Rate, na.rm = FALSE)
  inflation_df$index_ratio <- inflation_df$Reset_Rate/inflation_data$Reset_Rate[1]

  t_valuation_df <- t_valuation_df[,-(8:10)]  # remove old PV and payment rows which are recalculated below


  # Join the valuation table with inflation table
  t_valuation_df <- t_valuation_df %>%
    left_join(
      x = t_valuation_df,
      y = inflation_df,
      by = c("pay_date" = "date")
    )


  t_valuation_df <- t_valuation_df[,-(8:9)]  # remove reset date and rate


  t_valuation_df <- t_valuation_df %>%
    mutate(
      real_notional = notional*index_ratio,
      real_principle_payment = principle_payment*index_ratio,
      interest_payment = decimal_days*equiv_coupon*real_notional,
      payment = (interest_payment + real_principle_payment)*i_fx,
      PV = payment*discount_rate
    )

  return(t_valuation_df)

}




#-------------------------------------------------------------------------------
# Server & UI
#-------------------------------------------------------------------------------



source("ui.R")

source("server.R")



#-------------------------------------------------------------------------------
# Run App
#-------------------------------------------------------------------------------

shinyApp(ui = ui, server = server)

